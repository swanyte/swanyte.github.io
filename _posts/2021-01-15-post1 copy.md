---
layout: article
title: 백준 포스팅(2) 12865 - 파이썬 풀이
categories:
  [백준, dp, 파이썬, Knapsack Problem]
tags:
  [백준, dp, 파이썬, Knapsack Problem]
key: 백준 포스팅 2
---

## 백준 12865번 - 평범한 배낭(골드5)

[12865 문제 링크](https://www.acmicpc.net/problem/12865)

<center><img src="/image/21-01-15/12865_0.png"></center>
---

### 배낭 문제(Knapsack Problem)
#### 배낭에 담을 수 있는 무게의 최대값이 정해져 있고, 일정한 가치와 무게가 정해져 있는 짐들을 배낭에 담을 때, 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제
#### 저번 학기 알고리즘 수업 때 배운 Dynamic programming 중 Knapsack Problem이다. 문제 자체는 기본적인 배낭 문제 그 자체인데 배운 내용을 까먹어서…좀 헤매면서 풀었다. 그때도 코드는 구현을 안했기 때문에 이번 기회에 처음으로 코드 구현까지 하며 제대로 풀 수 있었다.

#### 우선 무게와 가치를 입력받는 2차원 배열인 li를 생성하였다.
<center><img src="/image/21-01-15/12865_1.png"></center>

#### 수업 때 알고리즘을 푸는데 필요한 표는 아직 기억이 났기 때문에 표부터 먼저 그리고 문제를 풀었다.
<center><img src="/image/21-01-15/12865_2.png"></center>

#### 오른쪽 위 회색 칸은 허용가능한 최대 무게이다. 문제 예시로는 7이 주어졌기 때문에 7까지 생성하였다.
#### 이제 표를 살펴보자. 첫번째 줄에서는 무게가 6이다. 최대 허용 무게가 0~5까지는 6을 수용할 수 없기 때문에 가치는 0이 된다. 최대 허용 무게가 6과 7일 때 무게 6을 넣어 가치가 13이 된다. 
#### 두번째 줄에서 마찬가지로 4 미만일 때는 가치가 0이 되다가 4에서부터 가치 8이 들어온다. 하지만 허용 가능한 최대 무게가 6이 되었을 때는 이전에 입력된 값도 고려되어야 하기 때문에 13이 들어온다.
#### 그 이후에도 위와 같은 방식으로 반복된다. 그러나 약간 달라지는 구간이 있다. W와 V가 3, 6이고 허용 가능한 최대무게가 7일 때를 보자. 가치가 14가 되었지만 입력된 값에는 어디에도 14는 없다. 그렇다면 어떻게 된 일일까? 바로 W가 4일 때와 3일 때의 가치인 8과 6이 더해진 것이다. 이 경우를 잘 고려해서 코드를 짜야 한다. 나같은 경우에는 표는 잘 그렸지만 이게 어떤 경우에 이런 상황이 생기는지 떠올리기가 어려워 많이 헤맸다.
---
### 최종 코드
##### 설명의 한계를 느껴 코드를 보며 설명하겠다...

```python
# 정답 
import sys
N, K = map(int, sys.stdin.readline().split())
li = [[0 for j in range(N)] for i in range(2)]
dp = [[0 for j in range(K+1)] for i in range(N+1)]
for i in range(N):
    li[0][i], li[1][i] = map(int, sys.stdin.readline().split())
for i in range(1, N+1):
    for j in range(1, K+1):
        if li[0][i-1] <= j:
            dp[i][j] = max(li[1][i-1]+dp[i-1][j-li[0][i-1]],dp[i-1][j])
        else:
            dp[i][j] = dp[i-1][j]            
print(dp[N][K])
```
###### 코드만 있으면 너무 작길래 캡쳐도 첨부한다.
<center><img src="/image/21-01-15/12865_12.png"></center>
---
<center><img src="/image/21-01-15/12865_3.png"></center>

##### 결론적으로는 dp의 마지막 값을 출력하면 된다.
##### 위에 먼저 구현했던 표보다 행과 열 모두 하나씩 증가한 것을 알 수 있다.
#### 왜 이렇게 했을까? 표의 이전 행과 열의 값에 따라 뒤의 행과 열의 값이 변해야 하기 때문이다. 이를 위해 위아래로 한 칸씩 늘려주고 이중 for문 모두 1부터 시작하였다. 

<center><img src="/image/21-01-15/12865_4.png"></center>
---

#### 본격적으로 조건문에 대해 설명하겠다.

<center><img src="/image/21-01-15/12865_5.png"></center>

#### else 문을 먼저 확인해보자. li[0][i-1] > j인 경우에는 리스트 dp의 이전 행, 같은 열의 값을 가져온다.

<center><img src="/image/21-01-15/12865_6.png"></center>


#### if 문을 확인해보자. li[0][i-1] <= j인 경우에는 리스트 li의 가치 V와 리스트 dp에서의 이전 행, 현재 무게에서 li의 무게를 뺀 값에 해당하는 열의 값과 더한 값과 이전 행, 같은 열(즉, 지금 칸의 바로 윗 칸)의 값을 비교 후 그 중 큰 값을 읽는다.
#### 말로 설명하기에는 정말 이해도 안되고 난해하게 느껴진다. 이전에 설명한 8과 14의 경우를 생각하면 된다. 그림과 예시를 보고 이해해보자. 

<center><img src="/image/21-01-15/12865_7.png"></center>

<center><img src="/image/21-01-15/12865_8.png"></center>

#### 이후 dp[N][K], dp 배열의 가장 마지막 값을 읽으면 정답이 된다.
### 결과 화면
<center><img src="/image/21-01-15/12865_10.png"></center>

<center><img src="/image/21-01-15/12865_11.png"></center>

###### Thonny는 옆에 이렇게 정리되어 나오는게 좋다.
---
#### 배열 두개 li, dp를 한 줄에서 같이 비교하면서 코딩을 해서 많이 헷갈렸다. 좀 더 깔끔하게 푸는 방법이 있을 듯 하다.

<center><img src="/image/21-01-15/12865_9.png"></center>

#### 문제를 푼 후 강의자료에는 어떻게 나와있었나 하고 살펴보았다. 동일하다고 보면 될 듯 하다.

---
### 느낀점
#### 블로그에 올려야지...올려야지...하다가 꽤 늦게 포스팅하게 되었다. 내가 짠 코드였는데도 다시 보니 헷갈렸다. 앞으로는 풀면 바로바로 포스팅 하는 버릇을 가져야겠다.
##### 애초에 다른 사람에게 설명한다는 것 자체가 어려운 듯 하다... 앞으로 하다 보면 익숙해지길 바란다.